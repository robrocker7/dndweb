{"version":3,"file":"tinybind.min.js","sources":["../src/constants.js","../src/parsers.js","../src/observer.js","../src/tinybind.js","../src/view.js","../src/binders.js","../src/bindings.js","../src/adapter.js","../src/component.js","../src/export.js","../src/formatters.js"],"sourcesContent":["export const OPTIONS = [\r\n  'prefix',\r\n  'templateDelimiters',\r\n  'rootInterface',\r\n  'preloadData',\r\n  'handler'\r\n]\r\n\r\nexport const EXTENSIONS = [\r\n  'binders',\r\n  'formatters',\r\n  'adapters'\r\n]","const PRIMITIVE = 0\r\nconst KEYPATH = 1\r\nconst TEXT = 0\r\nconst BINDING = 1\r\n\r\nconst QUOTED_STR = /^'.*'$|^\".*\"$/\r\n\r\n// Parser and tokenizer for getting the type and value from a string.\r\nexport function parseType(string) {\r\n  let type = PRIMITIVE\r\n  let value = string\r\n\r\n  if (QUOTED_STR.test(string)) {\r\n    value = string.slice(1, -1)\r\n  } else if (string === 'true') {\r\n    value = true\r\n  } else if (string === 'false') {\r\n    value = false\r\n  } else if (string === 'null') {\r\n    value = null\r\n  } else if (string === 'undefined') {\r\n    value = undefined\r\n  } else if (!isNaN(string)) {\r\n    value = Number(string)\r\n  } else {\r\n    type = KEYPATH\r\n  }\r\n\r\n  return {type: type, value: value}\r\n}\r\n\r\n// Template parser and tokenizer for mustache-style text content bindings.\r\n// Parses the template and returns a set of tokens, separating static portions\r\n// of text from binding declarations.\r\nexport function parseTemplate(template, delimiters) {\r\n  var tokens\r\n  let length = template.length\r\n  let index = 0\r\n  let lastIndex = 0\r\n  let open = delimiters[0], close = delimiters[1]\r\n\r\n  while (lastIndex < length) {\r\n    index = template.indexOf(open, lastIndex)\r\n\r\n    if (index < 0) {\r\n      if (tokens) {\r\n        tokens.push({\r\n          type: TEXT,\r\n          value: template.slice(lastIndex)\r\n        })\r\n      }\r\n\r\n      break\r\n    } else {\r\n      tokens || (tokens = [])\r\n      if (index > 0 && lastIndex < index) {\r\n        tokens.push({\r\n          type: TEXT,\r\n          value: template.slice(lastIndex, index)\r\n        })\r\n      }\r\n\r\n      lastIndex = index + open.length\r\n      index = template.indexOf(close, lastIndex)\r\n\r\n      if (index < 0) {\r\n        let substring = template.slice(lastIndex - close.length)\r\n        let lastToken = tokens[tokens.length - 1]\r\n\r\n        if (lastToken && lastToken.type === TEXT) {\r\n          lastToken.value += substring\r\n        } else {\r\n          tokens.push({\r\n            type: TEXT,\r\n            value: substring\r\n          })\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      let value = template.slice(lastIndex, index).trim()\r\n\r\n      tokens.push({\r\n        type: BINDING,\r\n        value: value\r\n      })\r\n\r\n      lastIndex = index + close.length\r\n    }\r\n  }\r\n\r\n  return tokens\r\n}\r\n","\r\n// Check if a value is an object than can be observed.\r\nfunction isObject(obj) {\r\n  return typeof obj === 'object' && obj !== null\r\n}\r\n\r\n// Error thrower.\r\nfunction error(message) {\r\n  throw new Error(`[Observer] ${message}`)\r\n}\r\n\r\nlet adapters;\r\nlet interfaces;\r\nlet rootInterface;\r\n\r\n// Constructs a new keypath observer and kicks things off.\r\nclass Observer {\r\n  static updateOptions (options) {\r\n    adapters = options.adapters\r\n    interfaces = Object.keys(adapters)\r\n    rootInterface = options.rootInterface\r\n  }\r\n  \r\n  // Tokenizes the provided keypath string into interface + path tokens for the\r\n  // observer to work with.\r\n  static tokenize (keypath, root) {\r\n    const tokens = [];\r\n    let current = {i: root, path: ''};\r\n    let index;\r\n    let chr;\r\n  \r\n    for (index = 0; index < keypath.length; index++) {\r\n      chr = keypath.charAt(index)\r\n  \r\n      if (!!~interfaces.indexOf(chr)) {\r\n        tokens.push(current)\r\n        current = {i: chr, path: ''}\r\n      } else {\r\n        current.path += chr\r\n      }\r\n    }\r\n  \r\n    tokens.push(current)\r\n    return tokens\r\n  }\r\n\r\n  constructor(obj, keypath, callback) {\r\n    this.keypath = keypath\r\n    this.callback = callback\r\n    this.objectPath = []\r\n    this.parse()\r\n    this.obj = this.getRootObject(obj)\r\n\r\n    if (isObject(this.target = this.realize())) {\r\n      this.set(true, this.key, this.target, this.callback)\r\n    }\r\n  }\r\n\r\n  // Parses the keypath using the interfaces defined on the view. Sets variables\r\n  // for the tokenized keypath as well as the end key.\r\n  parse() {\r\n    let path;\r\n    let root;\r\n\r\n    if (!interfaces.length) {\r\n      error('Must define at least one adapter interface.')\r\n    }\r\n\r\n    if (!!~interfaces.indexOf(this.keypath[0])) {\r\n      root = this.keypath[0]\r\n      path = this.keypath.substr(1)\r\n    } else {\r\n      root = rootInterface\r\n      path = this.keypath\r\n    }\r\n\r\n    this.tokens = Observer.tokenize(path, root)\r\n    this.key = this.tokens.pop()\r\n  }\r\n\r\n  // Realizes the full keypath, attaching observers for every key and correcting\r\n  // old observers to any changed objects in the keypath.\r\n  realize() {\r\n    let current = this.obj;\r\n    let unreached = -1;\r\n    let prev;\r\n    let token;\r\n\r\n    for (let index = 0; index < this.tokens.length; index++) {\r\n      token = this.tokens[index]\r\n      if (isObject(current)) {\r\n        if (typeof this.objectPath[index] !== 'undefined') {\r\n          if (current !== (prev = this.objectPath[index])) {\r\n            this.set(false, token, prev, this)\r\n            this.set(true, token, current, this)\r\n            this.objectPath[index] = current\r\n          }\r\n        } else {\r\n          this.set(true, token, current, this)\r\n          this.objectPath[index] = current\r\n        }\r\n\r\n        current = this.get(token, current)\r\n      } else {\r\n        if (unreached === -1) {\r\n          unreached = index\r\n        }\r\n\r\n        if (prev = this.objectPath[index]) {\r\n          this.set(false, token, prev, this)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (unreached !== -1) {\r\n      this.objectPath.splice(unreached)\r\n    }\r\n\r\n    return current\r\n  }\r\n\r\n  // Updates the keypath. This is called when any intermediary key is changed.\r\n  sync() {\r\n    let next;\r\n    let oldValue;\r\n    let newValue;\r\n\r\n    if ((next = this.realize()) !== this.target) {\r\n      if (isObject(this.target)) {\r\n        this.set(false, this.key, this.target, this.callback)\r\n      }\r\n\r\n      if (isObject(next)) {\r\n        this.set(true, this.key, next, this.callback)\r\n      }\r\n\r\n      oldValue = this.value()\r\n      this.target = next\r\n      newValue = this.value()\r\n      if (newValue !== oldValue || newValue instanceof Function) this.callback.sync()\r\n    } else if (next instanceof Array) {\r\n      this.callback.sync()\r\n    }\r\n  }\r\n\r\n  // Reads the current end value of the observed keypath. Returns undefined if\r\n  // the full keypath is unreachable.\r\n  value() {\r\n    if (isObject(this.target)) {\r\n      return this.get(this.key, this.target)\r\n    }\r\n  }\r\n\r\n  // Sets the current end value of the observed keypath. Calling setValue when\r\n  // the full keypath is unreachable is a no-op.\r\n  setValue(value) {\r\n    if (isObject(this.target)) {\r\n      adapters[this.key.i].set(this.target, this.key.path, value)\r\n    }\r\n  }\r\n\r\n  // Gets the provided key on an object.\r\n  get(key, obj) {\r\n    return adapters[key.i].get(obj, key.path);\r\n  }\r\n\r\n  // Observes or unobserves a callback on the object using the provided key.\r\n  set(active, key, obj, callback) {\r\n    const action = active ? 'observe' : 'unobserve';\r\n    adapters[key.i][action](obj, key.path, callback)\r\n  }\r\n\r\n  // Unobserves the entire keypath.\r\n  unobserve() {\r\n    let obj;\r\n    let token;\r\n\r\n    for (let index = 0; index < this.tokens.length; index++) {\r\n      token = this.tokens[index]\r\n      if (obj = this.objectPath[index]) {\r\n        this.set(false, token, obj, this)\r\n      }\r\n    }\r\n\r\n    if (isObject(this.target)) {\r\n      this.set(false, this.key, this.target, this.callback)\r\n    }\r\n  }\r\n\r\n  // traverse the scope chain to find the scope which has the root property\r\n  // if the property is not found in chain, returns the root scope\r\n  getRootObject(obj) {\r\n    let rootProp;\r\n    let current;\r\n    if (!obj.$parent) {\r\n      return obj;\r\n    }\r\n\r\n    if (this.tokens.length) {\r\n      rootProp = this.tokens[0].path\r\n    } else {\r\n      rootProp = this.key.path\r\n    }\r\n\r\n    current = obj;\r\n    while (current.$parent && (current[rootProp] === undefined)) {\r\n      current = current.$parent\r\n    }\r\n\r\n    return current;\r\n  }\r\n}\r\n\r\nexport default Observer\r\n","import {EXTENSIONS} from './constants'\r\nimport {parseTemplate, parseType} from './parsers'\r\n\r\nconst tinybind = {\r\n  // Global binders.\r\n  binders: {},\r\n\r\n  // Global formatters.\r\n  formatters: {},\r\n\r\n  // Global sightglass adapters.\r\n  adapters: {},\r\n\r\n  // Default attribute prefix.\r\n  _prefix: 'rv',\r\n\r\n  _fullPrefix: 'rv-',\r\n\r\n  get prefix () {\r\n    return this._prefix\r\n  },\r\n\r\n  set prefix (value) {\r\n    this._prefix = value\r\n    this._fullPrefix = value + '-'\r\n  },\r\n\r\n  parseTemplate: parseTemplate,\r\n\r\n  parseType: parseType,\r\n\r\n  // Default template delimiters.\r\n  templateDelimiters: ['{', '}'],\r\n\r\n  // Default sightglass root interface.\r\n  rootInterface: '.',\r\n\r\n  // Preload data by default.\r\n  preloadData: true,\r\n\r\n  // Default event handler.\r\n  handler: function(context, ev, binding) {\r\n    this.call(context, ev, binding.view.models)\r\n  },\r\n\r\n  // Sets the attribute on the element. If no binder above is matched it will fall\r\n  // back to using this binder.\r\n  fallbackBinder: function(el, value) {\r\n    if (value != null) {\r\n      el.setAttribute(this.type, value)\r\n    } else {\r\n      el.removeAttribute(this.type)\r\n    }  \r\n  },\r\n\r\n  // Merges an object literal into the corresponding global options.\r\n  configure: function(options) {\r\n    if (!options) {\r\n      return\r\n    }\r\n    Object.keys(options).forEach(option => {\r\n      let value = options[option]\r\n\r\n      if (EXTENSIONS.indexOf(option) > -1) {\r\n        Object.keys(value).forEach(key => {\r\n          this[option][key] = value[key]\r\n        })\r\n      } else {\r\n        this[option] = value\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport default tinybind\r\n","import tinybind from './tinybind'\r\nimport {Binding} from './bindings'\r\nimport {parseTemplate} from './parsers'\r\n\r\nconst textBinder = {\r\n  routine: (node, value) => {\r\n    node.data = (value != null) ? value : ''\r\n  }\r\n}\r\n\r\nconst DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g\r\n\r\nconst parseNode = (view, node) => {\r\n  let block = false\r\n\r\n  if (node.nodeType === 3) {\r\n    let tokens = parseTemplate(node.data, tinybind.templateDelimiters)\r\n\r\n    if (tokens) {\r\n      for (let i = 0; i < tokens.length; i++) {\r\n        let token = tokens[i]\r\n        let text = document.createTextNode(token.value)\r\n        node.parentNode.insertBefore(text, node)\r\n\r\n        if (token.type === 1) {\r\n          view.buildBinding(text, null, token.value, textBinder, null)\r\n        }\r\n      }\r\n\r\n      node.parentNode.removeChild(node)\r\n    }\r\n    block = true\r\n  } else if (node.nodeType === 1) {\r\n    block = view.traverse(node)\r\n  }\r\n\r\n  if (!block) {\r\n    for (let i = 0; i < node.childNodes.length; i++) {\r\n      parseNode(view, node.childNodes[i]);\r\n    }\r\n  }\r\n}\r\n\r\nconst bindingComparator = (a, b) => {\r\n  let aPriority = a.binder ? (a.binder.priority || 0) : 0\r\n  let bPriority = b.binder ? (b.binder.priority || 0) : 0\r\n  return bPriority - aPriority\r\n}\r\n\r\nconst trimStr = (str) => {\r\n  return str.trim()\r\n}\r\n\r\n// A collection of bindings built from a set of parent nodes.\r\nexport default class View {\r\n  // The DOM elements and the model objects for binding are passed into the\r\n  // constructor along with any local options that should be used throughout the\r\n  // context of the view and it's bindings.\r\n  constructor(els, models, options) {\r\n    if (els.jquery || els instanceof Array) {\r\n      this.els = els\r\n    } else {\r\n      this.els = [els]\r\n    }\r\n\r\n    this.models = models\r\n    this.options = options\r\n\r\n    this.build()\r\n  }\r\n\r\n\r\n  buildBinding(node, type, declaration, binder, arg) {\r\n    let pipes = declaration.match(DECLARATION_SPLIT).map(trimStr)\r\n\r\n    let keypath = pipes.shift()\r\n\r\n    this.bindings.push(new Binding(this, node, type, keypath, binder, arg, pipes))\r\n  }\r\n\r\n  // Parses the DOM tree and builds `Binding` instances for every matched\r\n  // binding declaration.\r\n  build() {\r\n    this.bindings = []\r\n\r\n    let elements = this.els, i, len;\r\n    for (i = 0, len = elements.length; i < len; i++) {\r\n      parseNode(this, elements[i])\r\n    }\r\n\r\n    this.bindings.sort(bindingComparator)\r\n  }\r\n\r\n  traverse(node) {\r\n    let bindingPrefix = tinybind._fullPrefix\r\n    let block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE'\r\n    let attributes = node.attributes\r\n    let bindInfos = []\r\n    let starBinders = this.options.starBinders\r\n    var type, binder, identifier, arg\r\n\r\n\r\n    for (let i = 0, len = attributes.length; i < len; i++) {\r\n      let attribute = attributes[i]\r\n      if (attribute.name.indexOf(bindingPrefix) === 0) {\r\n        type = attribute.name.slice(bindingPrefix.length)\r\n        binder = this.options.binders[type]\r\n        arg = undefined\r\n\r\n        if (!binder) {\r\n          for (let k = 0; k < starBinders.length; k++) {\r\n            identifier = starBinders[k]\r\n            if (type.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\r\n              binder = this.options.binders[identifier]\r\n              arg = type.slice(identifier.length - 1)\r\n              break\r\n            }\r\n          }\r\n        }\r\n\r\n        if (!binder) {\r\n          binder = tinybind.fallbackBinder\r\n        }\r\n\r\n        if (binder.block) {\r\n          this.buildBinding(node, type, attribute.value, binder, arg)\r\n          node.removeAttribute(attribute.name)\r\n          return true;\r\n        }\r\n\r\n        bindInfos.push({attr: attribute, binder: binder, type: type, arg: arg})\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < bindInfos.length; i++) {\r\n      let bindInfo = bindInfos[i]\r\n      this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.arg)\r\n      node.removeAttribute(bindInfo.attr.name)\r\n    }\r\n\r\n    return block\r\n  }\r\n\r\n  // Binds all of the current bindings for this view.\r\n  bind() {\r\n    this.bindings.forEach(binding => {\r\n      binding.bind()\r\n    })\r\n  }\r\n\r\n  // Unbinds all of the current bindings for this view.\r\n  unbind() {\r\n    this.bindings.forEach(binding => {\r\n      binding.unbind()\r\n    })\r\n  }\r\n\r\n  // Syncs up the view with the model by running the routines on all bindings.\r\n  sync() {\r\n    this.bindings.forEach(binding => {\r\n      binding.sync()\r\n    })\r\n  }\r\n\r\n  // Publishes the input values from the view back to the model (reverse sync).\r\n  publish() {\r\n    this.bindings.forEach(binding => {\r\n      if (binding.binder && binding.binder.publishes) {\r\n        binding.publish()\r\n      }\r\n    })\r\n  }\r\n\r\n  // Updates the view's models along with any affected bindings.\r\n  update(models = {}) {\r\n    Object.keys(models).forEach(key => {\r\n      this.models[key] = models[key]\r\n    })\r\n\r\n    this.bindings.forEach(binding => {\r\n      if (binding.update) {\r\n        binding.update(models)\r\n      }\r\n    })\r\n  }\r\n}\r\n","import View from './view'\r\n\r\nconst getString = (value) => {\r\n  return value != null ? value.toString() : undefined\r\n}\r\n\r\nconst times = (n, cb) => {\r\n  for (let i = 0; i < n; i++) cb()\r\n}\r\n\r\nfunction createView(binding, data, anchorEl) {\r\n  let template = binding.el.cloneNode(true)\r\n  let view = new View(template, data, binding.view.options)\r\n  view.bind()\r\n  binding.marker.parentNode.insertBefore(template, anchorEl)\r\n  return view\r\n}\r\n\r\nconst binders = {\r\n  // Binds an event handler on the element.\r\n  'on-*': {\r\n    function: true,\r\n    priority: 1000,\r\n\r\n    unbind: function(el) {\r\n      if (this.handler) {\r\n        el.removeEventListener(this.arg, this.handler)\r\n      }\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (this.handler) {\r\n        el.removeEventListener(this.arg, this.handler)\r\n      }\r\n\r\n      this.handler = this.eventHandler(value)\r\n      el.addEventListener(this.arg, this.handler)\r\n    }\r\n  },\r\n\r\n  // Appends bound instances of the element in place for each item in the array.\r\n  'each-*': {\r\n    block: true,\r\n\r\n    priority: 4000,\r\n\r\n    bind: function(el) {\r\n      if (!this.marker) {\r\n        this.marker = document.createComment(` tinybind: ${this.type} `)\r\n        this.iterated = []\r\n\r\n        el.parentNode.insertBefore(this.marker, el)\r\n        el.parentNode.removeChild(el)\r\n      } else {\r\n        this.iterated.forEach(view => {\r\n          view.bind()\r\n        })\r\n      }\r\n    },\r\n\r\n    unbind: function(el) {\r\n      if (this.iterated) {\r\n        this.iterated.forEach(view => {\r\n          view.unbind()\r\n        })\r\n      }\r\n    },\r\n\r\n    routine: function(el, collection) {\r\n      let modelName = this.arg\r\n      collection = collection || []\r\n      let indexProp = el.getAttribute('index-property') || '$index'\r\n\r\n      collection.forEach((model, index) => {\r\n        let data = {$parent: this.view.models}\r\n        data[indexProp] = index\r\n        data[modelName] = model\r\n        let view = this.iterated[index]\r\n\r\n        if (!view) {\r\n\r\n          let previous = this.marker\r\n\r\n          if (this.iterated.length) {\r\n            previous = this.iterated[this.iterated.length - 1].els[0]\r\n          }\r\n\r\n          view = createView(this, data, previous.nextSibling)\r\n          this.iterated.push(view)\r\n        } else {\r\n          if (view.models[modelName] !== model) {\r\n            // search for a view that matches the model\r\n            let matchIndex, nextView\r\n            for (let nextIndex = index + 1; nextIndex < this.iterated.length; nextIndex++) {\r\n              nextView = this.iterated[nextIndex]\r\n              if (nextView.models[modelName] === model) {\r\n                matchIndex = nextIndex\r\n                break\r\n              }\r\n            }\r\n            if (matchIndex !== undefined) {\r\n              // model is in other position\r\n              // todo: consider avoiding the splice here by setting a flag\r\n              // profile performance before implementing such change\r\n              this.iterated.splice(matchIndex, 1)\r\n              this.marker.parentNode.insertBefore(nextView.els[0], view.els[0])\r\n              nextView.models[indexProp] = index\r\n            } else {\r\n              //new model\r\n              nextView = createView(this, data, view.els[0])\r\n            }\r\n            this.iterated.splice(index, 0, nextView)\r\n          } else {\r\n            view.models[indexProp] = index\r\n          }\r\n        }\r\n      })\r\n\r\n      if (this.iterated.length > collection.length) {\r\n        times(this.iterated.length - collection.length, () => {\r\n          let view = this.iterated.pop()\r\n          view.unbind()\r\n          this.marker.parentNode.removeChild(view.els[0])\r\n        })\r\n      }\r\n\r\n      if (el.nodeName === 'OPTION') {\r\n        this.view.bindings.forEach(binding => {\r\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\r\n            binding.sync()\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    update: function(models) {\r\n      let data = {}\r\n\r\n      //todo: add test and fix if necessary\r\n\r\n      Object.keys(models).forEach(key => {\r\n        if (key !== this.arg) {\r\n          data[key] = models[key]\r\n        }\r\n      })\r\n\r\n      this.iterated.forEach(view => {\r\n        view.update(data)\r\n      })\r\n    }\r\n  },\r\n\r\n  // Adds or removes the class from the element when value is true or false.\r\n  'class-*': function(el, value) {\r\n    let elClass = ` ${el.className} `\r\n\r\n    if (!value === (elClass.indexOf(` ${this.arg} `) > -1)) {\r\n      if (value) {\r\n        el.className = `${el.className} ${this.arg}`\r\n      } else {\r\n        el.className = elClass.replace(` ${this.arg} `, ' ').trim()\r\n      }\r\n    }\r\n  },\r\n\r\n  // Sets the element's text value.\r\n  text: (el, value) => {\r\n    el.textContent = value != null ? value : ''\r\n  },\r\n\r\n  // Sets the element's HTML content.\r\n  html: (el, value) => {\r\n    el.innerHTML = value != null ? value : ''\r\n  },\r\n\r\n  // Shows the element when value is true.\r\n  show: (el, value) => {\r\n    el.style.display = value ? '' : 'none'\r\n  },\r\n\r\n  // Hides the element when value is true (negated version of `show` binder).\r\n  hide: (el, value) => {\r\n    el.style.display = value ? 'none' : ''\r\n  },\r\n\r\n  // Enables the element when value is true.\r\n  enabled: (el, value) => {\r\n    el.disabled = !value\r\n  },\r\n\r\n  // Disables the element when value is true (negated version of `enabled` binder).\r\n  disabled: (el, value) => {\r\n    el.disabled = !!value\r\n  },\r\n\r\n  // Checks a checkbox or radio input when the value is true. Also sets the model\r\n  // property when the input is checked or unchecked (two-way binder).\r\n  checked: {\r\n    publishes: true,\r\n    priority: 2000,\r\n\r\n    bind: function(el) {\r\n      var self = this;\r\n      if (!this.callback) {\r\n        this.callback = function () {\r\n          self.publish();\r\n        }\r\n      }\r\n      el.addEventListener('change', this.callback)\r\n    },\r\n\r\n    unbind: function(el) {\r\n      el.removeEventListener('change', this.callback)\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (el.type === 'radio') {\r\n        el.checked = getString(el.value) === getString(value)\r\n      } else {\r\n        el.checked = !!value\r\n      }\r\n    }\r\n  },\r\n\r\n  // Sets the element's value. Also sets the model property when the input changes\r\n  // (two-way binder).\r\n  value: {\r\n    publishes: true,\r\n    priority: 3000,\r\n\r\n    bind: function(el) {\r\n      this.isRadio = el.tagName === 'INPUT' && el.type === 'radio';\r\n      if (!this.isRadio) {\r\n        this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input')\r\n\r\n        var self = this;\r\n        if (!this.callback) {\r\n          this.callback = function () {\r\n            self.publish();\r\n          }\r\n        }\r\n\r\n        el.addEventListener(this.event, this.callback)\r\n      }\r\n    },\r\n\r\n    unbind: function(el) {\r\n      if (!this.isRadio) {\r\n        el.removeEventListener(this.event, this.callback)\r\n      }\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (this.isRadio) {\r\n        el.setAttribute('value', value)\r\n      } else {\r\n        if (el.type === 'select-multiple') {\r\n          if (value instanceof Array) {\r\n            for (let i = 0; i < el.length; i++) {\r\n              let option = el[i];\r\n              option.selected = value.indexOf(option.value) > -1\r\n            }\r\n          }\r\n        } else if (getString(value) !== getString(el.value)) {\r\n          el.value = value != null ? value : ''\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  // Inserts and binds the element and it's child nodes into the DOM when true.\r\n  if: {\r\n    block: true,\r\n    priority: 4000,\r\n\r\n    bind: function(el) {\r\n      if (!this.marker) {\r\n        this.marker = document.createComment(' tinybind: ' + this.type + ' ' + this.keypath + ' ');\r\n        this.attached = false\r\n\r\n        el.parentNode.insertBefore(this.marker, el)\r\n        el.parentNode.removeChild(el)\r\n      } else if (this.bound === false && this.nested) {\r\n        this.nested.bind()\r\n      }\r\n      this.bound = true\r\n    },\r\n\r\n    unbind: function() {\r\n      if (this.nested) {\r\n        this.nested.unbind()\r\n        this.bound = false\r\n      }\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (!!value !== this.attached) {\r\n        if (value) {\r\n\r\n          if (!this.nested) {\r\n            this.nested = new View(el, this.view.models, this.view.options)\r\n            this.nested.bind()\r\n          }\r\n\r\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling)\r\n          this.attached = true\r\n        } else {\r\n          el.parentNode.removeChild(el)\r\n          this.attached = false\r\n        }\r\n      }\r\n    },\r\n\r\n    update: function(models) {\r\n      if (this.nested) {\r\n        this.nested.update(models)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default binders\r\n","import {parseType} from './parsers'\r\nimport Observer from './observer'\r\n\r\nfunction getInputValue(el) {  \r\n  if (el.type === 'checkbox') {\r\n    return el.checked\r\n  } else if (el.type === 'select-multiple') {\r\n    const results = []\r\n    let option\r\n    for (let i = 0; i < el.options.length; i++) {\r\n      option = el.options[i]\r\n      if (option.selected) {\r\n        results.push(option.value);\r\n      }\r\n    }\r\n    return results\r\n  } else {\r\n    return el.value\r\n  }\r\n}\r\n\r\nconst FORMATTER_ARGS =  /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g\r\nconst FORMATTER_SPLIT = /\\s+/\r\n\r\n// A single binding between a model attribute and a DOM element.\r\nexport class Binding {\r\n  // All information about the binding is passed into the constructor; the\r\n  // containing view, the DOM node, the type of binding, the model object and the\r\n  // keypath at which to listen for changes.\r\n  constructor(view, el, type, keypath, binder, arg, formatters) {\r\n    this.view = view\r\n    this.el = el\r\n    this.type = type\r\n    this.keypath = keypath\r\n    this.binder = binder\r\n    this.arg = arg\r\n    this.formatters = formatters\r\n    this.formatterObservers = {}\r\n    this.model = undefined\r\n  }\r\n\r\n  // Observes the object keypath\r\n  observe(obj, keypath) {\r\n    return new Observer(obj, keypath, this)\r\n  }\r\n\r\n  parseTarget() {\r\n    if (this.keypath) {\r\n      let token = parseType(this.keypath)\r\n\r\n      if (token.type === 0) {\r\n        this.value = token.value\r\n      } else {\r\n        this.observer = this.observe(this.view.models, this.keypath)\r\n        this.model = this.observer.target\r\n      }\r\n    } else {\r\n      this.value = undefined;\r\n    }\r\n  }\r\n\r\n  parseFormatterArguments(args, formatterIndex) {\r\n    return args\r\n      .map(parseType)\r\n      .map(({type, value}, ai) => {\r\n        if (type === 0) {\r\n          return value\r\n        } else {\r\n          if (!this.formatterObservers[formatterIndex]) {\r\n            this.formatterObservers[formatterIndex] = {}\r\n          }\r\n\r\n          let observer = this.formatterObservers[formatterIndex][ai]\r\n\r\n          if (!observer) {\r\n            observer = this.observe(this.view.models, value)\r\n            this.formatterObservers[formatterIndex][ai] = observer\r\n          }\r\n\r\n          return observer.value()\r\n        }\r\n      })\r\n  }\r\n\r\n  // Applies all the current formatters to the supplied value and returns the\r\n  // formatted value.\r\n  formattedValue(value) {\r\n    return this.formatters.reduce((result, declaration, index) => {\r\n      let args = declaration.match(FORMATTER_ARGS)\r\n      let id = args.shift()\r\n      let formatter = this.view.options.formatters[id]\r\n\r\n      const processedArgs = this.parseFormatterArguments(args, index)\r\n\r\n      if (formatter && (formatter.read instanceof Function)) {\r\n        result = formatter.read(result, ...processedArgs)\r\n      } else if (formatter instanceof Function) {\r\n        result = formatter(result, ...processedArgs)\r\n      }\r\n      return result\r\n    }, value)\r\n  }\r\n\r\n  // Returns an event handler for the binding around the supplied function.\r\n  eventHandler(fn) {\r\n    let binding = this\r\n    let handler = binding.view.options.handler\r\n\r\n    return function(ev) {\r\n      handler.call(fn, this, ev, binding)\r\n    }\r\n  }\r\n\r\n  // Sets the value for the binding. This Basically just runs the binding routine\r\n  // with the supplied value formatted.\r\n  set(value) {\r\n    if ((value instanceof Function) && !this.binder.function) {\r\n      value = this.formattedValue(value.call(this.model))\r\n    } else {\r\n      value = this.formattedValue(value)\r\n    }\r\n\r\n    let routineFn = this.binder.routine || this.binder\r\n\r\n    if (routineFn instanceof Function) {\r\n      routineFn.call(this, this.el, value)\r\n    }\r\n  }\r\n\r\n  // Syncs up the view binding with the model.\r\n  sync() {\r\n    if (this.observer) {\r\n      this.model = this.observer.target\r\n      this.set(this.observer.value())\r\n    } else {\r\n      this.set(this.value)\r\n    }\r\n  }\r\n\r\n  // Publishes the value currently set on the input element back to the model.\r\n  publish() {\r\n    if (this.observer) {\r\n      var value = this.formatters.reduceRight((result, declaration, index) => {\r\n        const args = declaration.split(FORMATTER_SPLIT)\r\n        const id = args.shift()\r\n        const formatter = this.view.options.formatters[id]\r\n        const processedArgs = this.parseFormatterArguments(args, index)\r\n\r\n        if (formatter && formatter.publish) {\r\n          result = formatter.publish(result, ...processedArgs)\r\n        }\r\n        return result\r\n      }, this.getValue(this.el))\r\n\r\n      this.observer.setValue(value)\r\n    }\r\n  }\r\n\r\n  // Subscribes to the model for changes at the specified keypath. Bi-directional\r\n  // routines will also listen for changes on the element to propagate them back\r\n  // to the model.\r\n  bind() {\r\n    this.parseTarget()\r\n\r\n    if (this.binder.hasOwnProperty('bind')) {\r\n      this.binder.bind.call(this, this.el)\r\n    }\r\n\r\n    if (this.view.options.preloadData) {\r\n      this.sync()\r\n    }\r\n  }\r\n\r\n  // Unsubscribes from the model and the element.\r\n  unbind() {\r\n    if (this.binder.unbind) {\r\n      this.binder.unbind.call(this, this.el)\r\n    }\r\n\r\n    if (this.observer) {\r\n      this.observer.unobserve()\r\n    }\r\n\r\n    Object.keys(this.formatterObservers).forEach(fi => {\r\n      let args = this.formatterObservers[fi]\r\n\r\n      Object.keys(args).forEach(ai => {\r\n        args[ai].unobserve()\r\n      })\r\n    })\r\n\r\n    this.formatterObservers = {}\r\n  }\r\n\r\n  // Updates the binding's model from what is currently set on the view. Unbinds\r\n  // the old model first and then re-binds with the new model.\r\n  update(models = {}) {\r\n    if (this.observer) {\r\n      this.model = this.observer.target\r\n    }\r\n\r\n    if (this.binder.update) {\r\n      this.binder.update.call(this, models)\r\n    }\r\n  }\r\n\r\n  // Returns elements value\r\n  getValue(el) {\r\n    if (this.binder && this.binder.getValue) {\r\n      return this.binder.getValue.call(this, el)\r\n    } else {\r\n      return getInputValue(el)\r\n    }\r\n  }\r\n}\r\n","// The default `.` adapter that comes with tinybind.js. Allows subscribing to\r\n// properties on plain objects, implemented in ES5 natives using\r\n// `Object.defineProperty`.\r\n\r\nconst ARRAY_METHODS = [\r\n  'push',\r\n  'pop',\r\n  'shift',\r\n  'unshift',\r\n  'sort',\r\n  'reverse',\r\n  'splice'\r\n]\r\n\r\nconst adapter = {\r\n  counter: 0,\r\n  weakmap: {},\r\n\r\n  weakReference: function(obj) {\r\n    if (!obj.hasOwnProperty('__rv')) {\r\n      let id = this.counter++\r\n\r\n      Object.defineProperty(obj, '__rv', {\r\n        value: id\r\n      })\r\n    }\r\n\r\n    if (!this.weakmap[obj.__rv]) {\r\n      this.weakmap[obj.__rv] = {\r\n        callbacks: {}\r\n      }\r\n    }\r\n\r\n    return this.weakmap[obj.__rv]\r\n  },\r\n\r\n  cleanupWeakReference: function(data, refId) {\r\n    if (!Object.keys(data.callbacks).length) {\r\n      if (!(data.pointers && Object.keys(data.pointers).length)) {\r\n        delete this.weakmap[refId]\r\n      }\r\n    }\r\n  },\r\n\r\n  stubFunction: function(obj, fn) {\r\n    const original = obj[fn]\r\n    const data = this.weakReference(obj)\r\n    const weakmap = this.weakmap\r\n\r\n    obj[fn] = (...args) => {\r\n      let response = original.apply(obj, args)\r\n\r\n      Object.keys(data.pointers).forEach(refId => {\r\n        let k = data.pointers[refId]\r\n\r\n        if (weakmap[refId]) {\r\n          if (weakmap[refId].callbacks[k] instanceof Array) {\r\n            weakmap[refId].callbacks[k].forEach(callback => {\r\n              callback.sync()\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      return response\r\n    }\r\n  },\r\n\r\n  observeArray: function(value, refId, keypath) {\r\n    if (value instanceof Array) {\r\n      let data = this.weakReference(value)\r\n\r\n      if (!data.pointers) {\r\n        data.pointers = {}\r\n\r\n        ARRAY_METHODS.forEach(fn => {\r\n          this.stubFunction(value, fn)\r\n        })\r\n      }\r\n\r\n      if (!data.pointers[refId]) {\r\n        data.pointers[refId] = []\r\n      }\r\n\r\n      if (data.pointers[refId].indexOf(keypath) === -1) {\r\n        data.pointers[refId].push(keypath)\r\n      }\r\n    }\r\n  },\r\n\r\n  unobserveArray: function(value, refId, keypath) {\r\n    if ((value instanceof Array) && (value.__rv != null)) {\r\n      let data = this.weakmap[value.__rv]\r\n\r\n      if (data) {\r\n        let pointers = data.pointers[refId]\r\n\r\n        if (pointers) {\r\n          let idx = pointers.indexOf(keypath)\r\n\r\n          if (idx > -1) {\r\n            pointers.splice(idx, 1)\r\n          }\r\n\r\n          if (!pointers.length) {\r\n            delete data.pointers[refId]\r\n          }\r\n\r\n          this.cleanupWeakReference(data, value.__rv)\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  observe: function(obj, keypath, callback) {\r\n    let value    \r\n    const callbacks = this.weakReference(obj).callbacks\r\n\r\n    if (!callbacks[keypath]) {\r\n      callbacks[keypath] = []\r\n      let desc = Object.getOwnPropertyDescriptor(obj, keypath)\r\n\r\n      if (!desc || !(desc.get || desc.set || !desc.configurable)) {\r\n        value = obj[keypath]\r\n\r\n        Object.defineProperty(obj, keypath, {\r\n          enumerable: true,\r\n\r\n          get: () => {\r\n            return value\r\n          },\r\n\r\n          set: newValue => {\r\n            if (newValue !== value) {\r\n              this.unobserveArray(value, obj.__rv, keypath)\r\n              value = newValue\r\n              const data = this.weakmap[obj.__rv]\r\n\r\n              if (data) {\r\n                let callbacks = data.callbacks[keypath]\r\n\r\n                if (callbacks) {\r\n                  callbacks.forEach(cb => {\r\n                      cb.sync()\r\n                  })\r\n                }\r\n\r\n                this.observeArray(newValue, obj.__rv, keypath)\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    if (callbacks[keypath].indexOf(callback) === -1) {\r\n      callbacks[keypath].push(callback)\r\n    }\r\n\r\n    this.observeArray(obj[keypath], obj.__rv, keypath)\r\n  },\r\n\r\n  unobserve: function(obj, keypath, callback) {\r\n    let data = this.weakmap[obj.__rv]\r\n\r\n    if (data) {\r\n      let callbacks = data.callbacks[keypath]\r\n\r\n      if (callbacks) {\r\n        let idx = callbacks.indexOf(callback)\r\n\r\n        if (idx > -1) {\r\n          callbacks.splice(idx, 1)\r\n\r\n          if (!callbacks.length) {\r\n            delete data.callbacks[keypath]\r\n            this.unobserveArray(obj[keypath], obj.__rv, keypath)\r\n          }\r\n        }\r\n\r\n        this.cleanupWeakReference(data, obj.__rv)\r\n      }\r\n    }\r\n  },\r\n\r\n  get: function(obj, keypath) {\r\n    return obj[keypath]\r\n  },\r\n\r\n  set: (obj, keypath, value) => {\r\n    obj[keypath] = value\r\n  }\r\n}\r\n\r\nexport default adapter\r\n","\r\nimport tinybind from './tinybind'\r\n\r\nclass Component extends HTMLElement {\r\n  static get observedAttributes() {\r\n    const template = this.template\r\n    if (!template) {\r\n      throw new Error(`No template declared for ${this.name}`)\r\n    }\r\n\r\n    this.__templateEl = document.createElement('template')\r\n    this.__templateEl.innerHTML = template\r\n    \r\n    const propAttributeMap = this.__propAttributeMap = {}\r\n    const attributes = []\r\n    const properties = this.properties\r\n    if (properties) {\r\n      Object.keys(properties).forEach(propName => {\r\n        const propConfig = properties[propName]\r\n        const attrName = typeof propConfig === 'string' ? propConfig : propName\r\n        propAttributeMap[attrName] = propName\r\n        attributes.push(attrName)\r\n      })\r\n    }    \r\n    return attributes\r\n  }\r\n\r\n  connectedCallback() {\r\n    const nodes = this.constructor.__templateEl.content.cloneNode(true)\r\n    this.__tinybindView = tinybind.bind(nodes, this)    \r\n    while (this.firstChild) {\r\n      this.removeChild(this.firstChild);\r\n    }\r\n    this.appendChild(nodes)\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.__tinybindView.unbind()    \r\n  }\r\n\r\n  attributeChangedCallback(name, old, value) {\r\n    if (old !== value) {      \r\n      const propName = this.constructor.__propAttributeMap[name]\r\n      this[propName] = value\r\n    }\r\n  }  \r\n}\r\n\r\nexport default Component","import tinybind from './tinybind'\r\nimport View from './view'\r\nimport {OPTIONS, EXTENSIONS} from './constants'\r\nimport adapter from './adapter'\r\nimport binders from './binders'\r\nimport formatters from './formatters'\r\nimport Observer from './observer'\r\nimport Component from './component'\r\n\r\n// Returns the public interface.\r\n\r\ntinybind.binders = binders\r\ntinybind.formatters = formatters\r\ntinybind.adapters['.'] = adapter\r\ntinybind.Component = Component\r\n\r\n// Binds some data to a template / element. Returns a tinybind.View instance.\r\ntinybind.bind = (el, models, options) => {\r\n  let viewOptions = {}\r\n  models = models || {}\r\n  options = options || {}\r\n\r\n  EXTENSIONS.forEach(extensionType => {\r\n    viewOptions[extensionType] = Object.create(null)\r\n\r\n    if (options[extensionType]) {\r\n      Object.keys(options[extensionType]).forEach(key => {\r\n        viewOptions[extensionType][key] = options[extensionType][key]\r\n      })\r\n    }\r\n\r\n    Object.keys(tinybind[extensionType]).forEach(key => {\r\n      if (!viewOptions[extensionType][key]) {\r\n        viewOptions[extensionType][key] = tinybind[extensionType][key]\r\n      }\r\n    })\r\n  })\r\n\r\n  OPTIONS.forEach(option => {\r\n    let value = options[option]\r\n    viewOptions[option] = value != null ? value : tinybind[option]\r\n  })\r\n\r\n  viewOptions.starBinders = Object.keys(viewOptions.binders).filter(function (key) {\r\n    return key.indexOf('*') > 0\r\n  })\r\n\r\n  Observer.updateOptions(viewOptions)\r\n\r\n  let view = new View(el, models, viewOptions)\r\n  view.bind()\r\n  return view\r\n}\r\n\r\nexport default tinybind\r\n","const formatters = {\r\n  watch: function(value) {\r\n    return value;\r\n  },\r\n\r\n  not: function(value) {\r\n    return !value;\r\n  },\r\n\r\n  negate: function(value) {\r\n    return !value;\r\n  }\r\n}\r\n\r\nexport default formatters"],"names":["OPTIONS","EXTENSIONS","QUOTED_STR","parseType","string","type","value","test","slice","undefined","isNaN","Number","parseTemplate","template","delimiters","tokens","length","index","lastIndex","open","close","indexOf","push","substring","lastToken","trim","adapters","interfaces","rootInterface","tinybind","binders","formatters","_prefix","_fullPrefix","this","templateDelimiters","preloadData","handler","context","ev","binding","call","view","models","fallbackBinder","el","setAttribute","removeAttribute","configure","options","Object","keys","forEach","option","key","_this","isObject","obj","Observer","keypath","callback","objectPath","parse","getRootObject","target","realize","set","updateOptions","tokenize","root","chr","current","i","path","charAt","message","Error","error","substr","pop","prev","token","unreached","get","splice","sync","next","oldValue","newValue","Function","Array","setValue","active","action","unobserve","rootProp","$parent","parseNode","node","block","nodeType","data","text","document","createTextNode","parentNode","insertBefore","buildBinding","textBinder","removeChild","traverse","childNodes","bindingComparator","a","b","aPriority","binder","priority","trimStr","str","getString","toString","FORMATTER_ARGS","FORMATTER_SPLIT","Binding","arg","formatterObservers","model","observe","parseTarget","observer","parseFormatterArguments","args","formatterIndex","map","ai","formattedValue","reduce","result","declaration","match","id","shift","formatter","_this2","processedArgs","read","eventHandler","fn","function","routineFn","routine","publish","reduceRight","split","_this3","getValue","bind","hasOwnProperty","unbind","fi","_this4","update","checked","results","selected","getInputValue","DECLARATION_SPLIT","View","els","jquery","build","pipes","bindings","len","elements","sort","identifier","bindingPrefix","nodeName","attributes","bindInfos","starBinders","attribute","name","k","attr","bindInfo","publishes","ARRAY_METHODS","adapter","counter","weakmap","weakReference","defineProperty","__rv","callbacks","cleanupWeakReference","refId","pointers","stubFunction","original","response","apply","observeArray","unobserveArray","idx","desc","getOwnPropertyDescriptor","configurable","enumerable","cb","createView","anchorEl","cloneNode","marker","removeEventListener","addEventListener","iterated","createComment","collection","modelName","indexProp","getAttribute","matchIndex","nextView","nextIndex","previous","nextSibling","n","times","elClass","className","replace","textContent","html","innerHTML","show","style","display","hide","enabled","disabled","self","isRadio","tagName","event","if","bound","nested","attached","Component","connectedCallback","nodes","constructor","__templateEl","content","__tinybindView","firstChild","appendChild","disconnectedCallback","attributeChangedCallback","old","__propAttributeMap","createElement","propAttributeMap","properties","propName","propConfig","attrName","HTMLElement","watch","not","negate","viewOptions","extensionType","create","filter"],"mappings":"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"}